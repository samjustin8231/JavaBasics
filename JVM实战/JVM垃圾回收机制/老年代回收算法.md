# 老年代回收算法

其实把上面的内容都看懂之后，大家现在基本就知道了Minor GC的触发时机，然后就是Minor GC之前要对老年代空间大小做的检查



包括检查失败的时候要提前触发Full GC给老年代腾一些空间出来，或者是Minor GC过后剩余对象太多放入老年代内存都不够，也要触发Full GC。包括这套规则，还有触发老年代垃圾回收的Full GC时机，都给大家讲清楚了。



简单来说，一句话总结，对老年代触发垃圾回收的时机，一般就是两个：



要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；



要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。



那么对老年代进行垃圾回收采用的是什么算法呢？



简单来说，老年代采取的是标记整理算法，这个过程说起来比较简单



大家看下图，首先标记出来老年代当前存活的对象，这些对象可能是东一个西一个的。

接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片



然后再一次性把垃圾对象都回收掉，大家看下图。

大家一定要注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。



如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。



所以后面用各种案例给大家展现出来的，就是在各种业务系统的生产故障下，怎么去一步一步分析到底为什么频繁的Full GC，然后怎么来调整JVM的各种参数进行优化。



其实大家如果透彻理解了最近的几篇文章涵盖的JVM的运行原理，就会知道，所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。



关于如何优化JVM，后续会有大量的案例带着大家去实战，而且会给出模拟生产的代码，让大家运行起来看到模拟出来的案发现场是如何导致JVM频繁GC的，对性能是如何影响的，然后再一步一步来优化JVM参数解决性能问题。

